import pdfplumber
import pandas as pd
import re

def extract_bright_meadow():

    pdf_path = "bright_meadow.pdf"  # <-- Change this to your actual path

    # ── Extract fund name and table from PDF ──────────────────────────────────
    with pdfplumber.open(pdf_path) as pdf:
        page  = pdf.pages[0]
        
        # Extract fund name from top text
        full_text = page.extract_text()
        fund_name = ""
        if full_text:
            first_line = full_text.strip().split('\n')[0]
            fund_name  = first_line.strip()

        # Extract table
        tables = page.extract_tables()

    if not tables:
        print("❌ No tables found in PDF.")
        return

    # ── Use the largest table found ───────────────────────────────────────────
    table = max(tables, key=lambda t: len(t))

    print(f"Fund: {fund_name}")
    print(f"Table rows found: {len(table)}")
    print("\nRaw table (first 5 rows):")
    for row in table[:5]:
        print(row)

    # ── Convert to DataFrame ──────────────────────────────────────────────────
    # Flatten multi-line headers by joining non-None cells
    def clean_cell(cell):
        if cell is None:
            return ""
        return " ".join(cell.split())  # collapse whitespace/newlines

    # Build clean rows
    clean_table = [[clean_cell(cell) for cell in row] for row in table]

    # Find header row (row that contains "Period" or "Ending")
    header_idx = 0
    for i, row in enumerate(clean_table):
        row_text = " ".join(row).lower()
        if "period" in row_text or "ending" in row_text:
            header_idx = i
            break

    # Merge header rows if split across multiple rows (common in pdfplumber)
    # Combine rows up to and including header_idx as column names
    col_names = []
    for col_i in range(len(clean_table[header_idx])):
        parts = []
        for row_i in range(header_idx + 1):
            val = clean_table[row_i][col_i]
            if val:
                parts.append(val)
        col_names.append(" ".join(parts).strip())

    print(f"\nDetected columns: {col_names}")

    # Data rows start after header
    data_rows = clean_table[header_idx + 1:]
    df_full   = pd.DataFrame(data_rows, columns=col_names)

    print("\nFull DataFrame:")
    print(df_full.to_string(index=False))

    # ── Find December 2025 row ────────────────────────────────────────────────
    # Period column is likely the first column
    period_col = col_names[0]

    # Find column containing "Ending Equity"
    ending_col = next((c for c in col_names if "ending" in c.lower() and "equity" in c.lower()), None)

    # Find column containing "MTD Rate of Return"
    mtd_col = next((c for c in col_names if "mtd" in c.lower() and "rate" in c.lower()), None)

    # Fallback: search by index if names are messy
    if not ending_col:
        # Ending Equity is typically column index 4
        ending_col = col_names[4] if len(col_names) > 4 else None
    if not mtd_col:
        # MTD Rate of Return is typically column index 5
        mtd_col = col_names[5] if len(col_names) > 5 else None

    print(f"\nEnding Equity column : '{ending_col}'")
    print(f"MTD Rate of Return column: '{mtd_col}'")

    # Find the 2025 December row
    # Look for year marker "2025" then "December" after it
    in_2025    = False
    dec_row    = None

    for _, row in df_full.iterrows():
        period_val = str(row[period_col]).strip()
        if period_val == "2025":
            in_2025 = True
        if in_2025 and "december" in period_val.lower():
            dec_row = row
            break

    if dec_row is None:
        print("❌ Could not find December 2025 row.")
        print("Available periods:", df_full[period_col].tolist())
        return

    # ── Clean values ──────────────────────────────────────────────────────────
    def clean_number(val):
        if val is None or str(val).strip() in ("", "-", "None"):
            return None
        v = str(val).replace(',', '').replace('$', '').replace('%', '').strip()
        try:
            return float(v)
        except ValueError:
            return None

    ending_equity = clean_number(dec_row[ending_col])
    mtd_return    = clean_number(dec_row[mtd_col])

    # ── Build output DataFrame ────────────────────────────────────────────────
    result_df = pd.DataFrame([{
        "Fund Name"              : fund_name,
        "Period"                 : "December 2025",
        "Ending Equity"          : ending_equity,
        "MTD Rate of Return (%)" : mtd_return
    }])

    print("\n✅ Final Extracted Data:")
    print(result_df.to_string(index=False))

    return result_df


# ── Run ───────────────────────────────────────────────────────────────────────
df = extract_bright_meadow()
