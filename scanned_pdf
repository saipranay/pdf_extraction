import pdfplumber
import pandas as pd
import re

def extract_bright_meadow(pdf_path):
    """
    Works for any PDF in the same format:
    - Fund name at top
    - Performance table with year separator rows (2024, 2025)
    - Columns: Period, Beginning Equity, Additions, Withdrawals,
               Net Income, Ending Equity, MTD Rate of Return, ...
    """

    with pdfplumber.open(pdf_path) as pdf:
        page  = pdf.pages[0]
        words = page.extract_words(x_tolerance=3, y_tolerance=3)
        full_text = page.extract_text()

    fund_name = full_text.strip().split('\n')[0].strip() if full_text else ""

    # ── Group words into lines by y position ─────────────────────────────────
    lines = {}
    for w in words:
        key = round(w['top'] / 3) * 3
        lines.setdefault(key, []).append(w)

    line_keys = sorted(lines.keys())

    def get_line_words(key):
        return sorted(lines[key], key=lambda w: w['x0'])

    def line_text(key):
        return " ".join(w['text'] for w in get_line_words(key))

    # ── Dynamically find column x-centers from headers ────────────────────────
    # The headers may span multiple lines so we scan all lines for keywords
    # and record the x-center of each keyword word

    col_keywords = {
        "ending_equity" : ["ending"],
        "mtd_return"    : ["mtd"],
    }

    col_x = {k: None for k in col_keywords}

    for k in line_keys:
        for w in get_line_words(k):
            wt = w['text'].lower()
            for col_name, keywords in col_keywords.items():
                if col_x[col_name] is None:
                    for kw in keywords:
                        if kw in wt:
                            col_x[col_name] = (w['x0'] + w['x1']) / 2
                            print(f"  Found '{col_name}' header → '{w['text']}' at x={col_x[col_name]:.1f}")

    # Check we found both columns
    missing = [k for k, v in col_x.items() if v is None]
    if missing:
        print(f"⚠ Could not find headers for: {missing}")
        print("All lines:")
        for k in line_keys:
            print(f"  y={k}: {line_text(k)}")
        return None

    # ── Find the most recent year marker (highest year number in table) ───────
    year_keys = {}   # year_value → line_key
    for k in line_keys:
        lt = line_text(k).strip()
        if re.match(r'^\d{4}$', lt):
            year_keys[int(lt)] = k

    if not year_keys:
        print("❌ No year marker rows found.")
        return None

    latest_year     = max(year_keys.keys())
    latest_year_key = year_keys[latest_year]
    print(f"\nLatest year in table: {latest_year} at y={latest_year_key}")

    # ── Find December row after the latest year marker ────────────────────────
    dec_key = None
    for k in line_keys:
        if k <= latest_year_key:
            continue
        first_word = get_line_words(k)[0]['text'].lower()
        if "december" in first_word:
            dec_key = k
            break

    if dec_key is None:
        print(f"❌ No December row found after {latest_year}.")
        print(f"Rows after year marker:")
        for k in line_keys:
            if k > latest_year_key:
                print(f"  y={k}: {line_text(k)}")
        return None

    print(f"December {latest_year} row at y={dec_key} → {line_text(dec_key)}")

    # ── Extract value at each column x position ───────────────────────────────
    dec_words = get_line_words(dec_key)

    def get_value_near_x(target_x, row_words, tolerance=50):
        """Get the word whose x-center is closest to target_x within tolerance."""
        best_word, best_dist = None, float('inf')
        for w in row_words:
            wx    = (w['x0'] + w['x1']) / 2
            dist  = abs(wx - target_x)
            if dist < best_dist and dist < tolerance:
                best_dist = dist
                best_word = w
        return best_word['text'] if best_word else None

    def clean_number(val):
        if not val or str(val).strip() in ("", "-", "None"):
            return None
        v = str(val).replace(',', '').replace('$', '').replace('%', '').strip()
        try:
            return float(v)
        except ValueError:
            return None

    ending_raw = get_value_near_x(col_x["ending_equity"], dec_words)
    mtd_raw    = get_value_near_x(col_x["mtd_return"],    dec_words)

    print(f"\nRaw Ending Equity      : '{ending_raw}'")
    print(f"Raw MTD Rate of Return : '{mtd_raw}'")

    ending_equity = clean_number(ending_raw)
    mtd_return    = clean_number(mtd_raw)

    result_df = pd.DataFrame([{
        "Fund Name"              : fund_name,
        "Period"                 : f"December {latest_year}",
        "Ending Equity"          : ending_equity,
        "MTD Rate of Return (%)" : mtd_return
    }])

    print("\n✅ Final Extracted Data:")
    print(result_df.to_string(index=False))

    return result_df


# ── Run ───────────────────────────────────────────────────────────────────────
pdf_path = "bright_meadow.pdf"   # <-- Change this
df = extract_bright_meadow(pdf_path)
