import pdfplumber
import pandas as pd
import re
from difflib import SequenceMatcher

def extract_riva_capital():
    
    pdf_path = "riva_capital.pdf"          # <-- Change this to your actual path
    output_path = "Riva_Capital_Output.xlsx"

    row_labels = [
        "Total income",
        "Total expenses",
        "Net investment income(loss)",
        "Net realized gain(loss) on investments",
        "Net realized gain(loss) on FX",
        "Net change in unrealized gain(loss) on investments",
        "Net change in unrealized gain(loss) on FX",
        "Net increase in partners' capital from operations",
        "Gross Capital - beginning of period",
        "Net change in investors' capital from ops",
        "Capital contributions",
        "Capital distributions",
        "Gross Capital, end of period",
        "IRR (Unaffiliated LP's Only)",
    ]

    # ── Extract words from PDF ────────────────────────────────────────────────
    with pdfplumber.open(pdf_path) as pdf:
        page = pdf.pages[0]
        words = page.extract_words()

    # ── DEBUG: Print all words to find exact month header format ─────────────
    print("=" * 60)
    print("ALL WORDS FOUND IN PDF (first 100):")
    print("=" * 60)
    for w in words[:100]:
        print(f"  text='{w['text']}'  x0={w['x0']:.1f}  top={w['top']:.1f}")
    print("=" * 60)

    # ── Helpers ───────────────────────────────────────────────────────────────
    def fuzzy_score(a, b):
        a, b = a.lower(), b.lower()
        if a in b:
            return 100
        return int(SequenceMatcher(None, a, b).ratio() * 100)

    def is_number(text):
        t = text.strip()
        return bool(re.match(r'^[-]?\(?\d[\d,\.]*\)?%?$', t)) or t in ['-', '$']

    def clean_number(text):
        t = text.strip().replace(',', '').replace('$', '').replace('%', '')
        if t.startswith('(') and t.endswith(')'):
            t = '-' + t[1:-1]
        try:
            return float(t)
        except ValueError:
            return None

    # ── Detect month column x-positions (broader pattern) ────────────────────
    # Tries multiple common formats: Jan'25, Jan-25, Jan 25, January 2025, Jun25
    month_pattern = re.compile(
        r"^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|YTD)[\s'\-]?\d{2,4}$", re.I
    )

    header_words = []
    for w in words:
        cleaned = w['text'].replace("\u2019", "'").replace("\u2018", "'")
        if month_pattern.match(cleaned):
            header_words.append(w)

    # ── If still not found, try to detect by looking for adjacent year numbers ─
    if not header_words:
        print("⚠ Standard month pattern failed. Trying alternate detection...")
        month_names = ["jan","feb","mar","apr","may","jun",
                       "jul","aug","sep","oct","nov","dec","ytd"]
        header_words = [
            w for w in words
            if w['text'].strip().lower()[:3] in month_names
        ]

    if not header_words:
        print("\n❌ Could not detect month headers.")
        print("Please check the words printed above and share them so the pattern can be fixed.")
        return

    header_words.sort(key=lambda w: w['x0'])
    col_x = [(w['text'], w['x0'], w['x1']) for w in header_words]
    print("Detected columns:", [c[0] for c in col_x])
    months = [c[0] for c in col_x]  # Use whatever format the PDF actually has

    def assign_col(word):
        wx = (word['x0'] + word['x1']) / 2
        best_col, best_dist = None, float('inf')
        for name, cx0, cx1 in col_x:
            col_mid = (cx0 + cx1) / 2
            dist = abs(wx - col_mid)
            if dist < best_dist:
                best_dist = dist
                best_col = name
        return best_col

    # ── Group words into lines by y-position ──────────────────────────────────
    words_sorted = sorted(words, key=lambda w: (round(w['top'] / 4), w['x0']))
    lines = {}
    for w in words_sorted:
        key = round(w['top'] / 4)
        lines.setdefault(key, []).append(w)

    line_keys = sorted(lines.keys())

    def line_text(key):
        return " ".join(w['text'] for w in lines[key])

    # ── Match each label to a line and extract values ─────────────────────────
    output_rows = []

    for label in row_labels:
        best_key, best_score = None, 0
        for key in line_keys:
            lt = line_text(key)
            score = fuzzy_score(label, lt)
            if score > best_score:
                best_score = score
                best_key = key

        if best_score < 50:
            print(f"  ⚠ Could not find row: '{label}' (best score {best_score})")
            row_dict = {"Row Label": label}
            row_dict.update({m: None for m in months})
            output_rows.append(row_dict)
            continue

        print(f"  ✓ '{label}' → '{line_text(best_key)[:80]}' (score {best_score})")

        matched_line = lines[best_key]
        next_keys = [k for k in line_keys if k > best_key]
        extra_words = lines[next_keys[0]] if next_keys else []
        all_words_in_row = matched_line + extra_words

        row_dict = {"Row Label": label}
        row_dict.update({m: None for m in months})

        for w in all_words_in_row:
            if is_number(w['text']):
                col = assign_col(w)
                if col and row_dict.get(col) is None:
                    row_dict[col] = clean_number(w['text'])

        output_rows.append(row_dict)

    # ── Build DataFrame and save ──────────────────────────────────────────────
    df = pd.DataFrame(output_rows, columns=["Row Label"] + months)
    print("\nExtracted DataFrame:")
    print(df.to_string(index=False))

    df.to_excel(output_path, index=False)
    print(f"\nSaved to {output_path}")
    return df


extract_riva_capital()
