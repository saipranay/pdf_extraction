import pandas as pd
import openpyxl
import calendar
from datetime import datetime
from dateutil.relativedelta import relativedelta
from openpyxl.styles import Font, Alignment
from openpyxl.utils import get_column_letter

# ── CONFIG ───────────────────────────────────────────────────────────────────
WORKFLOW_PATH = r"G:\2 - Transitory Records\NAV\Hedge Funds\12_31_2025 Workflow.xlsx"
OUTPUT_PATH   = r"G:\2 - Transitory Records\NAV\Hedge Funds\NAV_Output.xlsx"

FUND_CODE_MAP = {
    "GH INTL":   "GH INTL",
    "ACPI, LP":  "ACPI, LP",
    "ACPII, LP": "ACPII, LP",
    "WCP, LP":   "WCP, LP",
}
# ─────────────────────────────────────────────────────────────────────────────


def find_col(df_cols, candidates):
    cols_lower = {c.lower(): c for c in df_cols}
    for cand in candidates:
        if cand.lower() in cols_lower:
            return cols_lower[cand.lower()]
    return None


def next_month_last_date(date_val) -> str:
    if pd.isna(date_val) or str(date_val).strip() in ("", "nan", "NaT"):
        return ""
    try:
        if isinstance(date_val, str):
            for fmt in ("%d %b %Y", "%Y-%m-%d", "%d/%m/%Y", "%m/%d/%Y", "%d-%m-%Y"):
                try:
                    dt = datetime.strptime(date_val.strip(), fmt)
                    break
                except ValueError:
                    continue
            else:
                dt = pd.to_datetime(date_val, dayfirst=True).to_pydatetime()
        else:
            dt = pd.to_datetime(date_val).to_pydatetime()

        next_month = dt + relativedelta(months=1)
        last_day   = calendar.monthrange(next_month.year, next_month.month)[1]
        return next_month.replace(day=last_day).strftime("%d %b %Y")
    except Exception as e:
        print(f"[WARNING] Could not parse date '{date_val}': {e}")
        return str(date_val)


def load_workflow(path):
    xl = pd.ExcelFile(path)
    sheet_name = next((s for s in xl.sheet_names if "workflow" in s.lower()), xl.sheet_names[0])
    print(f"[Workflow] Reading sheet: '{sheet_name}'")

    raw = pd.read_excel(path, sheet_name=sheet_name, header=0, dtype=str)
    for i, row in raw.iterrows():
        if any("fund" in str(v).lower() for v in row.values):
            raw = pd.read_excel(path, sheet_name=sheet_name, header=i, dtype=str)
            break

    raw.columns = [str(c).strip() for c in raw.columns]
    return raw


def map_and_export(extracted_df):
    # ── 1. Load workflow ─────────────────────────────────────────────────────
    wf = load_workflow(WORKFLOW_PATH)

    col_ucn  = find_col(wf.columns, ["Fund UCN", "UCN"])
    col_name = find_col(wf.columns, ["Fund Name", "Name"])
    col_code = find_col(wf.columns, ["Fund Code", "FundCode"])
    col_nav  = find_col(wf.columns, ["NAV (thous)", "NAV(thous)", "NAV"])
    col_date = find_col(wf.columns, ["DATE", "Start Date", "Nav Date"])

    print(f"[Workflow] Columns → UCN:{col_ucn} | Name:{col_name} | "
          f"Code:{col_code} | NAV:{col_nav} | Date:{col_date}")

    # ── 2. Build output rows ─────────────────────────────────────────────────
    rows = []
    for _, ext_row in extracted_df.iterrows():
        pdf_fund   = str(ext_row["Fund"]).strip()
        fund_code  = FUND_CODE_MAP.get(pdf_fund, pdf_fund)
        net_assets = float(str(ext_row["Net Assets"]).replace(",", "").replace("$", ""))
        mtd_pct    = float(ext_row["Month to Date"])

        if col_code:
            mask  = wf[col_code].str.strip().str.upper() == fund_code.strip().upper()
            match = wf[mask]
        else:
            match = pd.DataFrame()

        if match.empty:
            print(f"[WARNING] No workflow match for '{fund_code}' — skipping.")
            continue

        wf_row = match.iloc[0]

        nav_val = int(round(net_assets / 1000, 0))

        try:
            prev_nav = int(round(float(str(wf_row[col_nav]).replace(",", "").replace("$", "")), 0)) if col_nav else 0
        except (ValueError, TypeError):
            prev_nav = 0

        variance = int(round((nav_val - prev_nav) / prev_nav, 0)) if prev_nav != 0 else 0
        nav_date = next_month_last_date(wf_row[col_date] if col_date else "")

        rows.append({
            "Fund UCN":         wf_row[col_ucn]  if col_ucn  else "",
            "Fund Name":        wf_row[col_name] if col_name else pdf_fund,
            "Fund Code":        fund_code,
            "NAV Date":         nav_date,
            "NAV (thous)":      nav_val,
            "MTD":              mtd_pct,
            "Prev NAV (thous)": prev_nav,
            "Variance":         variance,
        })

    if not rows:
        print("[ERROR] No rows mapped. Check FUND_CODE_MAP keys match PDF fund names.")
        return

    # Sort ascending by Variance
    out_df = pd.DataFrame(rows).sort_values("Variance", ascending=True).reset_index(drop=True)

    print("\n[Output Preview]")
    print(out_df.to_string(index=False))

    # ── 3. Write plain Excel (no colours, no fills) ───────────────────────────
    wb = openpyxl.Workbook()
    ws = wb.active
    ws.title = "NAV Output"

    bold   = Font(name="Calibri", bold=True, size=11)
    normal = Font(name="Calibri", size=11)

    # Header row — bold, no fill
    for ci, h in enumerate(out_df.columns, 1):
        c = ws.cell(row=1, column=ci, value=h)
        c.font   = bold
        c.alignment = Alignment(horizontal="center", vertical="center")

    # Data rows — plain, no colours
    for ri, (_, row) in enumerate(out_df.iterrows(), 2):
        for ci, val in enumerate(row.values, 1):
            c = ws.cell(row=ri, column=ci, value=val)
            c.font   = normal
            hdr = out_df.columns[ci - 1]
            if hdr in ("NAV (thous)", "Prev NAV (thous)"):
                c.number_format = "#,##0"
            elif hdr == "MTD":
                c.number_format = "0.0"
            elif hdr == "Variance":
                c.number_format = "0"           # rounded to integer, no decimals

    # Column widths
    for ci, w in enumerate([14, 30, 12, 16, 16, 8, 18, 14], 1):
        ws.column_dimensions[get_column_letter(ci)].width = w

    ws.freeze_panes = "A2"
    wb.save(OUTPUT_PATH)
    print(f"\n[Done] Output saved → {OUTPUT_PATH}")


# ── ENTRY POINT ───────────────────────────────────────────────────────────────
map_and_export(df)
