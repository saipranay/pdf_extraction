import pandas as pd
import openpyxl
import calendar
from datetime import datetime
from dateutil.relativedelta import relativedelta
from openpyxl.styles import Font, PatternFill, Alignment, Border, Side
from openpyxl.utils import get_column_letter

# ── CONFIG ───────────────────────────────────────────────────────────────────
WORKFLOW_PATH = r"G:\2 - Transitory Records\NAV\Hedge Funds\12_31_2025 Workflow.xlsx"
OUTPUT_PATH   = r"G:\2 - Transitory Records\NAV\Hedge Funds\NAV_Output.xlsx"

FUND_CODE_MAP = {
    "GH INTL":   "GH INTL",
    "ACPI, LP":  "ACPI, LP",
    "ACPII, LP": "ACPII, LP",
    "WCP, LP":   "WCP, LP",
}
# ─────────────────────────────────────────────────────────────────────────────


def find_col(df_cols, candidates):
    cols_lower = {c.lower(): c for c in df_cols}
    for cand in candidates:
        if cand.lower() in cols_lower:
            return cols_lower[cand.lower()]
    return None


def next_month_last_date(date_val) -> str:
    """
    Given a date (string or datetime), return the last day of the NEXT month.
    Example: 30 Oct 2025 → 30 Nov 2025
    """
    if pd.isna(date_val) or str(date_val).strip() in ("", "nan", "NaT"):
        return ""
    try:
        if isinstance(date_val, str):
            # Try common formats
            for fmt in ("%d %b %Y", "%Y-%m-%d", "%d/%m/%Y", "%m/%d/%Y", "%d-%m-%Y"):
                try:
                    dt = datetime.strptime(date_val.strip(), fmt)
                    break
                except ValueError:
                    continue
            else:
                dt = pd.to_datetime(date_val, dayfirst=True)
                dt = dt.to_pydatetime()
        else:
            dt = pd.to_datetime(date_val).to_pydatetime()

        # Move to next month
        next_month = dt + relativedelta(months=1)
        # Last day of that next month
        last_day = calendar.monthrange(next_month.year, next_month.month)[1]
        nav_date = next_month.replace(day=last_day)
        return nav_date.strftime("%d %b %Y")   # e.g. "30 Nov 2025"
    except Exception as e:
        print(f"[WARNING] Could not parse date '{date_val}': {e}")
        return str(date_val)


def load_workflow(path):
    xl = pd.ExcelFile(path)
    sheet_name = next((s for s in xl.sheet_names if "workflow" in s.lower()), xl.sheet_names[0])
    print(f"[Workflow] Reading sheet: '{sheet_name}'")

    raw = pd.read_excel(path, sheet_name=sheet_name, header=0, dtype=str)

    # Auto-detect header row
    for i, row in raw.iterrows():
        if any("fund" in str(v).lower() for v in row.values):
            raw = pd.read_excel(path, sheet_name=sheet_name, header=i, dtype=str)
            break

    raw.columns = [str(c).strip() for c in raw.columns]
    return raw


def map_and_export(extracted_df):
    """
    Merges extracted_df (from day_nav8.py) with workflow Excel and writes output.

    Column logic:
        Prev NAV (thous)  ← NAV (thous) column FROM workflow
        NAV (thous)       ← Net Assets from PDF / 1000
        NAV Date          ← last day of next month after workflow DATE
        Variance          ← NAV (thous) [extracted] - Prev NAV [workflow]
    """
    # ── 1. Load workflow ─────────────────────────────────────────────────────
    wf = load_workflow(WORKFLOW_PATH)

    col_ucn  = find_col(wf.columns, ["Fund UCN", "UCN"])
    col_name = find_col(wf.columns, ["Fund Name", "Name"])
    col_code = find_col(wf.columns, ["Fund Code", "FundCode"])
    col_nav  = find_col(wf.columns, ["NAV (thous)", "NAV(thous)", "NAV"])   # ← Prev NAV source
    col_date = find_col(wf.columns, ["DATE", "Start Date", "Nav Date"])     # ← base date for NAV Date

    print(f"[Workflow] Columns → UCN:{col_ucn} | Name:{col_name} | "
          f"Code:{col_code} | NAV:{col_nav} | Date:{col_date}")

    # ── 2. Build output rows ─────────────────────────────────────────────────
    rows = []
    for _, ext_row in extracted_df.iterrows():
        pdf_fund   = str(ext_row["Fund"]).strip()
        fund_code  = FUND_CODE_MAP.get(pdf_fund, pdf_fund)
        net_assets = float(str(ext_row["Net Assets"]).replace(",", "").replace("$", ""))
        mtd_pct    = float(ext_row["Month to Date"])

        # Match workflow row by Fund Code
        if col_code:
            mask  = wf[col_code].str.strip().str.upper() == fund_code.strip().upper()
            match = wf[mask]
        else:
            match = pd.DataFrame()

        if match.empty:
            print(f"[WARNING] No workflow match for '{fund_code}' — skipping.")
            continue

        wf_row = match.iloc[0]

        # ── MODIFICATION 1 & 2 ──────────────────────────────────────────────
        # Prev NAV = workflow NAV (thous)  [the old/current nav from workflow]
        try:
            prev_nav = float(str(wf_row[col_nav]).replace(",", "").replace("$", "")) if col_nav else 0.0
        except (ValueError, TypeError):
            prev_nav = 0.0

        # NAV = extracted Net Assets as-is (no division)
        nav_thous = round(net_assets, 3)

        # ── MODIFICATION 3 ──────────────────────────────────────────────────
        # NAV Date = last day of next month after workflow DATE
        raw_date = wf_row[col_date] if col_date else ""
        nav_date = next_month_last_date(raw_date)

        # ── MODIFICATION 4 ──────────────────────────────────────────────────
        # Variance = extracted NAV (thous) - Prev NAV (workflow thous)
        variance = round(nav_thous - prev_nav, 3)

        rows.append({
            "Fund UCN":         wf_row[col_ucn]  if col_ucn  else "",
            "Fund Name":        wf_row[col_name] if col_name else pdf_fund,
            "Fund Code":        fund_code,
            "NAV Date":         nav_date,                  # mod 3: next month last day
            "NAV":              nav_thous,                 # raw extracted value
            "MTD (%)":          mtd_pct,
            "Prev NAV (thous)": round(prev_nav, 3),        # mod 1: from workflow
            "Variance (thous)": variance,                  # mod 4: new - prev
        })

    if not rows:
        print("[ERROR] No rows mapped. Check FUND_CODE_MAP keys match PDF fund names.")
        return

    out_df = pd.DataFrame(rows)
    print("\n[Output Preview]")
    print(out_df.to_string(index=False))

    # ── 3. Write formatted Excel ─────────────────────────────────────────────
    wb = openpyxl.Workbook()
    ws = wb.active
    ws.title = "NAV Output"

    thin   = Side(style="thin", color="AAAAAA")
    border = Border(left=thin, right=thin, top=thin, bottom=thin)
    center = Alignment(horizontal="center", vertical="center", wrap_text=True)

    # Header
    ws.row_dimensions[1].height = 28
    h_fill = PatternFill("solid", fgColor="1F4E79")
    h_font = Font(name="Arial", bold=True, color="FFFFFF", size=11)
    for ci, h in enumerate(out_df.columns, 1):
        c = ws.cell(row=1, column=ci, value=h)
        c.fill = h_fill; c.font = h_font; c.alignment = center; c.border = border

    # Data rows
    alt  = PatternFill("solid", fgColor="DCE6F1")
    wht  = PatternFill("solid", fgColor="FFFFFF")
    dfnt = Font(name="Arial", size=10)

    for ri, (_, row) in enumerate(out_df.iterrows(), 2):
        fill = alt if ri % 2 == 0 else wht
        for ci, val in enumerate(row.values, 1):
            c = ws.cell(row=ri, column=ci, value=val)
            c.font = dfnt; c.border = border; c.fill = fill
            hdr = out_df.columns[ci - 1]
            if any(k in hdr for k in ("NAV", "Prev NAV", "Variance")):
                c.number_format = "#,##0.000"
            elif "MTD" in hdr:
                c.number_format = '0.0"%"'
            # Variance: green if positive, red if negative
            if "Variance" in hdr:
                try:
                    if float(val) >= 0:
                        c.font = Font(name="Arial", size=10, color="006100")
                    else:
                        c.font = Font(name="Arial", size=10, color="9C0006")
                except (ValueError, TypeError):
                    pass

    # Column widths
    for ci, w in enumerate([14, 30, 12, 16, 16, 10, 18, 18], 1):
        ws.column_dimensions[get_column_letter(ci)].width = w

    ws.freeze_panes = "A2"
    wb.save(OUTPUT_PATH)
    print(f"\n[Done] Output saved → {OUTPUT_PATH}")


# ── ENTRY POINT ───────────────────────────────────────────────────────────────
# df already defined by: df = extract_from_pdf(PDF_PATH) in day_nav8.py
map_and_export(df)
